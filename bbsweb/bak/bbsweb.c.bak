/*******************************************************************
 *			Nation Sun-Yat Sen Unversity
 *			Formosa WEB Server
 *			Start Develop at 1997.7.12 by Cauchy
 *			Take over at 1998.o.x by Riemann
 *******************************************************************/

/*
 * 含括檔區 
 */

#include <malloc.h>
#include <netdb.h>
#include <ctype.h>
#include <strings.h>
#include <sys/wait.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <sys/resource.h>
#include <sys/types.h>
#include <sys/ipc.h>
#include <sys/sem.h>
#include <string.h>

#include "bbs.h"
#include "webbbs.h"
#include "log.h"
#include "bbswebproto.h"

/* define Golbal Variables */
char username[IDLEN];
char password[PASSLEN];
char auth_code[STRLEN];
USEREC curuser;
int PSCorrect;						/* password correct or not */
REQUEST_REC *request_rec;			/* client request header */
SERVER_REC *server;

static int RUNNING = 777;

HTML_SHM *html_shm;
FILE_SHM *file_shm;

SKIN_FILE *skin_file;				/* the HTML skin */
POST_FILE *post_file;				/* the POST content */
BOARDHEADER *cboard;

sigjmp_buf env;

#ifdef PRE_FORK
static int sem_id;
static int my_num = 0;
#endif

FILE *fp_in, *fp_out;
int mysocket;

char BBS_SUBDIR[PATHLEN];
char WEBBBS_ERROR_MESSAGE[PATHLEN];


#ifdef WEB_ACCESS_LOG
char log[HTTP_REQUEST_LINE_BUF];	/* buffer for weblog() */
#endif

#ifdef TORNADO_OPTIMIZE
BOOL isTORNADO;
#endif


/*******************************************************************
 *	reaper - clean up zombie children
 *******************************************************************/
static void reaper(int sig)
{
	pid_t cpid;
#if	defined(SOLARIS) || defined(AIX) || defined(LINUX)
	int status;
#else
	union wait status;
#endif /* SOLARIS */

	while ((cpid = wait3(&status, WNOHANG, (struct rusage *) 0)) > 0)
	{
#ifdef PRE_FORK
		int i;
#endif
		server->child++;
#ifdef PRE_FORK
		for(i=0; i<server->max_child; i++)
		{
			if((server->childs)[i].pid == cpid)
			{
				(server->childs)[i].pid = 0x00;
				(server->childs)[i].status = S_ERROR;
				server->error++;
#ifdef WEB_ERROR_LOG
				sprintf(log, "ERR=\"Child unexpected return, pid=%d, status=%d (%s)\"", 
					(int)cpid, (int)status, strsignal(status));
				weblog_line(log, server->error_log, "127.0.0.1", time(0));
				fflush(server->error_log);
#endif
			}
		}
#endif
	}

	(void) signal(SIGCHLD, reaper);			/* 再度啟動 signal 接收 */
	
}

#ifdef KEEP_ALIVE
static void lingering_close(int sock)
{
	char dummybuf[512];
	struct timeval tv;
	fd_set lfds;
	int select_rv;
	
	shutdown(STDOUT_FILENO, 1);
	
	FD_ZERO(&lfds);
	FD_SET(sock, &lfds);
	
	do {
		tv.tv_sec = 2;
		tv.tv_usec = 0;
		select_rv = select(sock + 1, &lfds, NULL, NULL, &tv);
	} while((select_rv > 0) 
#if 0
	&& (read(sock, dummybuf, sizeof dummybuf) > 0));
#endif
	&& (fgets(dummybuf, sizeof(dummybuf), fp_in) != NULL));

	close(sock);
	
}
#endif

/*******************************************************************
 *	Dispatch command according to $type, $tag
 *
 *******************************************************************/
void DoTagCommand(char *type, char *tag)
{

	if(!strcasecmp(type, "Post"))
	{
		ShowPost(tag, cboard, post_file);
	}
	else if(!strcasecmp(type, "PostList"))
	{
		ShowPostList(tag, cboard, post_file);
	}
	else if(!strcasecmp(type, "User"))
	{
		ShowUser(tag, &curuser);
	}
	else if(!strcasecmp(type, "UserList"))
	{
		ShowUserList(tag, post_file);
	}
	else if(!strcasecmp(type, "Mail"))
	{
		ShowMail(tag);
	}
	else if(!strcasecmp(type, "Board"))
	{
		ShowBoard(tag, cboard, post_file);
	}
	else if(!strcasecmp(type, "BoardList"))
	{
		ShowBoardList(tag, post_file);
	}
	else if(!strcasecmp(type, "SubDir"))
	{
		fprintf(fp_out, "/%s", BBS_SUBDIR);
	}
	else if(!strcasecmp(type, "Message"))
	{
		fprintf(fp_out, "%s", WEBBBS_ERROR_MESSAGE);
	}
	else if(!strcasecmp(type, "Server"))
	{
		ShowServerInfo(tag, server, request_rec, file_shm, html_shm);
	}
	else if(!strcasecmp(type, "Proxy"))
	{
		if(strlen(request_rec->via))
		{
			char proxy[STRLEN*2];
			
			xstrncpy(proxy, request_rec->via+4, sizeof(proxy));
			strtok(proxy, ",(");
			fprintf(fp_out, "%s", proxy);
		}
	}
	else if(!strcasecmp(type, "Skin"))
	{
		if(PSCorrect==Correct && (cboard->brdtype & BRD_WEBSKIN) && 
		(!strcmp(username, cboard->owner) || HAS_PERM(PERM_SYSOP)))
			fprintf(fp_out, "<a href=\"/%sboards/%s/%s\">[BM]修改看板介面</a>", 
				BBS_SUBDIR, cboard->filename, HTML_SkinModify);
	}
	else if(!strcasecmp(type, "Announce"))
	{
		ShowArticle(WELCOME, FALSE, TRUE);
	}
	else if(!strcasecmp(type, "NewGuide"))
	{
		ShowArticle(NEWGUIDE, FALSE, TRUE);
	}

}

/*******************************************************************
 *	拆解 URI 成為三段
 *	
 *	不作額外判斷
 *******************************************************************/
void GetURIToken(char *boardname, char *post, char *skin, char *uri)
{
	char *token;
	
#if 0
	fprintf(fp_out, "[GetURIToken uri=%s]\r\n", uri);
	fflush(fp_out);
#endif	

#if 0
	sscanf(uri, "%[^/]/%s/%[^/]", boardname, post, skin);
	return;
#endif
	
#if 1
	if((token = strchr(uri, '/')) != NULL) /* get this as BOARDNAME */
	{
		*token = '\0';
		xstrncpy(boardname, uri, BNAMELEN);
		if(strlen(token)==1)
			return;
		else
			uri = token + 1;
	}
	else
	{
		/* put uri in skin for latter use */
		xstrncpy(skin, uri, PATHLEN);
		return;
	}
	
	if((token = strrchr(uri, '/')) != NULL)	/* find last token */
	{
		*token = '\0';
		xstrncpy(post, uri, PATHLEN);
		if(strlen(token) != 1)
			xstrncpy(skin, token+1, PATHLEN);
	}
	else
	{
		xstrncpy(skin, uri, PATHLEN);
	}
#endif


}


/*******************************************************************
 *	從 URI 判斷要求及抓出有用的資訊
 *	set BOARDNAME, POST_NAME, SKIN_FILE
 *
 *	return URLParaType
 *******************************************************************/
int ParseURI(const char *uri, REQUEST_REC *r, BOARDHEADER *board, POST_FILE *pf)
{
	char *p, *curi, *boardname;
	int HttpRequestType;
	char skin[PATHLEN], post[PATHLEN], ouri[URI_LEN];
	
	*skin = '\0';
	*post = '\0';
	
	boardname = board->filename;
	HttpRequestType = r->HttpRequestType;
	bzero(BBS_SUBDIR, sizeof(BBS_SUBDIR));
	
	xstrncpy(ouri, uri, URI_LEN);
	curi = ouri;

	if((p = strstr(curi, "/treasure/")) != NULL)
	{
		/*
			subdir/treasure/bname/
			subdir/treasure/bname/start-end
			subdir/treasure/bname/treadir/treapost
		*/
		
		xstrncpy(BBS_SUBDIR, curi+1, p-curi+1);
		curi = p + 10;

		GetURIToken(boardname, post, skin, curi);
		
#if 0
		fprintf(fp_out, "[BOARDNAME=%s, post=%s, skin=%s]<br>", boardname, post, skin);
		fflush(fp_out);
#endif

		if(HttpRequestType == POST)
		{
			xstrncpy(pf->POST_NAME, post, PATHLEN);

			if(!strcmp(skin, POST_PostSend))
				return TreaSend;
			else if(!strcmp(skin, POST_PostForward))
				return TreaForward;
			else if(!strcmp(skin, POST_PostDelete))
				return TreaDelete;
			else
				return Board;
		}

		if(strlen(boardname)==0)	/* no BOARDNAME assigned , list all boards */
		{
			if(strlen(skin)==0)
			{
				sprintf(skin_file->filename, "%s%s%s", HTML_PATH, BBS_SUBDIR, HTML_TreaBoardList);
				return TreaBoardList;
			}
			else
			{
				/* skin is boardname */
				sprintf(skin_file->filename, "/%streasure/%s/", BBS_SUBDIR, skin);
				return Redirect;
			}
		}
		
		if(strlen(skin)==0)		/* must be treasure dir */
		{
			if(strlen(post)==0)
			{
				settreafile(pf->POST_NAME, board->filename, DIR_REC);
			}
			else
			{
				settreafile(pf->POST_NAME, board->filename, post);
				strcat(pf->POST_NAME, "/");
				strcat(pf->POST_NAME, DIR_REC);
			}
			
			sprintf(skin_file->filename, "%s%s%s", HTML_PATH, BBS_SUBDIR, HTML_TreaList);
			return TreaList;
		}
		
		if(strlen(post))	/* has treasure sub-dir*/
		{
			settreafile(pf->POST_NAME, boardname, post);
			strcat(pf->POST_NAME, "/");
			strcat(pf->POST_NAME, skin);
		}
		else
		{
			settreafile(pf->POST_NAME, boardname, skin);
		}

		if(isPost(skin))
		{
			strip_html(pf->POST_NAME);
			sprintf(skin_file->filename, "%s%s%s", HTML_PATH, BBS_SUBDIR, HTML_TreaPost);
			return TreaRead;
		}
		
		if(isdir(pf->POST_NAME))	/* check isdir before isPost */
		{
			sprintf(skin_file->filename, "/%s%s/", BBS_SUBDIR, pf->POST_NAME);
			return Redirect;
		}
		
		sprintf(skin_file->filename, "%s%s%s", HTML_PATH, BBS_SUBDIR, skin);
		if(CacheState(skin_file->filename, NULL) >=0
		|| isfile(skin_file->filename))
		{
			if(strlen(post)==0)
				return TreaList;
			
			settreafile(pf->POST_NAME, board->filename, post);
			return TreaRead;
		}
		
		if(isList(skin, &(pf->list_start), &(pf->list_end)))
		{
			if(strlen(post)==0)
			{
				settreafile(pf->POST_NAME, board->filename, DIR_REC);
			}
			else
			{
				sprintf(pf->POST_NAME, "treasure/%s/%s/%s", boardname, post, DIR_REC);
			}
			
			sprintf(skin_file->filename, "%s%s%s", HTML_PATH, BBS_SUBDIR, HTML_TreaList);
			return TreaList;
		}
		else
		{
			settreafile(skin_file->filename, boardname, skin);
			return Board;
		}
		
	}
	else if((p = strstr(curi, "/boards/")) != NULL)
	{
		/*
			subdir/board/bname/
			subdir/board/bname/start-end
			subdir/board/bname/post
		*/
		
		xstrncpy(BBS_SUBDIR, curi+1, p-curi+1);
		curi = p + 8;
		
		GetURIToken(boardname, post, skin, curi);
		
#if 0
		fprintf(fp_out, "[BOARDNAME=%s, post=%s, skin=%s]<br>", boardname, post, skin);
		fflush(fp_out);
#endif

		if(HttpRequestType == POST)
		{
			xstrncpy(pf->POST_NAME, post, PATHLEN);

			if(!strcmp(skin, POST_PostSend))
				return PostSend;
			else if(!strcmp(skin, POST_PostEdit))
				return PostEdit;
			else if(!strcmp(skin, POST_PostForward))
				return PostForward;
			else if(!strcmp(skin, POST_PostDelete))
				return PostDelete;
			else if(!strcmp(skin, POST_BoardModify))
				return BoardModify;
			else if(!strcmp(skin, POST_SkinModify))
				return SkinModify;
			else
				return Board;
		}

		if(strlen(boardname)==0)
		{
			/* case:
				/boards/ 
				/boards/boardname
			*/

			if(strlen(skin)==0)
			{
				sprintf(skin_file->filename, "%s%s%s", HTML_PATH, BBS_SUBDIR, HTML_BoardList);
				return BoardList;
			}
			else
			{
				/* skin is boardname */
				sprintf(skin_file->filename, "/%sboards/%s/", BBS_SUBDIR, skin);
				return Redirect;
			}
		}
		
		if(strlen(skin)==0)
		{
			/* case: /boards/boardname/ */
			
			sprintf(skin_file->filename, "%s%s%s", HTML_PATH, BBS_SUBDIR, HTML_PostList);
			setboardfile(pf->POST_NAME, boardname, DIR_REC);
			return PostList;
		}
		
		if(isList(skin, &(pf->list_start), &(pf->list_end)))
		{
			setboardfile(pf->POST_NAME, board->filename, DIR_REC);
			sprintf(skin_file->filename, "%s%s%s", HTML_PATH, BBS_SUBDIR, HTML_PostList);
			return PostList;
		}
		
		if(isPost(skin))
		{
			strip_html(skin);
			
			setboardfile(pf->POST_NAME, boardname, skin);
			sprintf(skin_file->filename, "%s%s%s", HTML_PATH, BBS_SUBDIR, HTML_Post);
			return PostRead;
		}

		sprintf(skin_file->filename, "%s%s%s", HTML_PATH, BBS_SUBDIR, skin);

		if(CacheState(skin_file->filename, NULL) >=0
		|| isfile(skin_file->filename))
		{
			if(strlen(post)==0)		/* is DIR_REC skin */
			{
				if(!strcmp(skin, HTML_SkinModify))
				{
					*(pf->POST_NAME) = '\0';
					return SkinModify;
				}
				else
				{
					setboardfile(pf->POST_NAME, boardname, DIR_REC);
					return PostList;
				}
			}
			else					/* is post skin */
			{
				sprintf(pf->POST_NAME, "%s%s%s", HTML_PATH, BBS_SUBDIR, post);
			
				if(isfile(pf->POST_NAME))
				{
					sprintf(pf->POST_NAME, "%s%s%s", HTML_PATH, BBS_SUBDIR, post);
					return SkinModify;
				}
				else
				{
					setboardfile(pf->POST_NAME, board->filename, post);
					return PostRead;
				}
			}
		}
		
		setboardfile(skin_file->filename, boardname, skin);
		return Board;
		
	}
	else if((p = strstr(curi, "/mail/")) != NULL)
	{
		xstrncpy(BBS_SUBDIR, curi+1, p-curi+1);
		curi = p + 6;
		
		GetURIToken(boardname, post, skin, curi);
		
#if 0
		fprintf(fp_out, "[BOARDNAME=%s, post=%s, skin=%s]<br>", boardname, post, skin);
		fflush(fp_out);
#endif

		if(HttpRequestType == POST)
		{
			xstrncpy(pf->POST_NAME, boardname, PATHLEN);
			
			if(!strcmp(skin, POST_MailSend))
				return MailSend;
			else if(!strcmp(skin, POST_MailForward))
				return MailForward;
			else if(!strcmp(skin, POST_MailDelete))
				return MailDelete;
			else
				return OtherFile;
		}

		/* !! 'BOARDNAME' is 'post' in this section !! */
#if 0
		if(strlen(boardname)==0 && strlen(skin)==0)
		{
			sprintf(skin_file->filename, "%s%s", BBS_SUBDIR, HTML_MailList);
			setmailfile(pf->POST_NAME, username, DIR_REC);
			return MailList;
		}
#endif

		if(strlen(skin)==0)
		{
			sprintf(skin_file->filename, "%s%s%s", HTML_PATH, BBS_SUBDIR, HTML_MailList);
			setmailfile(pf->POST_NAME, username, DIR_REC);
			return MailList;
		}

		if(isList(skin, &(pf->list_start), &(pf->list_end)))
		{
			setmailfile(pf->POST_NAME, username, DIR_REC);
			sprintf(skin_file->filename, "%s%s%s", HTML_PATH, BBS_SUBDIR, HTML_MailList);
			return MailList;
		}
		
		if(isPost(skin))
		{
			strip_html(skin);
			setmailfile(pf->POST_NAME, username, skin);
			sprintf(skin_file->filename, "%s%s%s", HTML_PATH, BBS_SUBDIR, HTML_Mail);
			return MailRead;
		}

		sprintf(skin_file->filename, "%s%s%s", HTML_PATH, BBS_SUBDIR, skin);
		
		if(CacheState(skin_file->filename, NULL) >=0
		|| isfile(skin_file->filename))
		{
			if(strlen(board->filename) != 0)
			{
				setmailfile(pf->POST_NAME, username, boardname);
				return MailRead;
			}
			else
			{
				setmailfile(pf->POST_NAME, username, DIR_REC);
				return MailList;
			}
		}
		
		setmailfile(skin_file->filename, username, skin);
		return Mail;
		
	}
	else if((p = strstr(curi, "/users/")) != NULL)
	{
		xstrncpy(BBS_SUBDIR, curi+1, p-curi+1);
		curi = p + 7;
		
		GetURIToken(board->filename, post, skin, curi);
		
#if 0
		fprintf(fp_out, "[BOARDNAME=%s, post=%s, skin=%s]", board->filename, post, skin);
		fflush(fp_out);
#endif		
		if(HttpRequestType == POST)
		{
			if(!strcmp(skin, POST_UserNew))
				return UserNew;
			else if(!strcmp(skin, POST_UserData))
				return UserData;
			else if(!strcmp(skin, POST_UserPlan))
				return UserPlan;
			else if(!strcmp(skin, POST_UserSign))
				return UserSign;
			else if(!strcmp(skin, POST_UserFriend))
				return UserFriend;
			else
				return OtherFile;
		}
		
		if(strlen(skin)==0)
		{
			if(strlen(board->filename)!=0)
			{
				xstrncpy(username, board->filename, IDLEN);
				sprintf(skin_file->filename, "%s%s%s", HTML_PATH, BBS_SUBDIR, HTML_UserQuery);
				return UserQuery;
			}
			else
			{
				sprintf(skin_file->filename, "%s%s%s", HTML_PATH, BBS_SUBDIR, HTML_UserList);
				return UserList;
			}
		}

		if(isList(skin, &(pf->list_start), &(pf->list_end)))
		{
			sprintf(skin_file->filename, "%s%s%s", HTML_PATH, BBS_SUBDIR, HTML_UserList);
			return UserList;
		}
		
		sprintf(skin_file->filename, "%s%s%s", HTML_PATH, BBS_SUBDIR, skin);
		
		if(CacheState(skin_file->filename, NULL) >=0
		|| isfile(skin_file->filename))
			return UserData;

		xstrncpy(username, skin, IDLEN);
		sprintf(skin_file->filename, "%s%s%s", HTML_PATH, BBS_SUBDIR, HTML_UserQuery);
		return UserQuery;
	
	}
	else if(!strncmp(curi, "/~", 2))	/* want user planfile only */
	{

		curi+=2;
		strtok(curi, " /\t\r\n");
#if 0
		fprintf(fp_out, "userplan name=%s ", curi);
		fflush(fp_out);
#endif

		xstrncpy(username, curi, IDLEN);
		sprintf(skin_file->filename, "%s%s", HTML_PATH, HTML_UserPlanShow);
		
		return UserQuery;
	
	}
	else
	{
#if 0
		fprintf(fp_out, "[other file=%s]", curi);
		fflush(fp_out);
#endif

#ifdef NSYSUBBS
		/* for compatiable with old URL parameter ================== */
		if((p = strstr(curi, "BoardName=")) != NULL 
		|| (p = strstr(curi, "boardname=")) != NULL)
		{
			p+=10;
			strtok(p, "?&/");
			sprintf(skin_file->filename, "/txtVersion/boards/%s/", p);
			return Redirect;
		}
		/* ========================================================= */
#endif
		xstrncpy(skin_file->filename, curi, PATHLEN);
		xstrncpy(BBS_SUBDIR, curi+1, PATHLEN);
		if((p = strrchr(BBS_SUBDIR, '/')) != NULL)
			*(p+1) = 0x00;
		else
			BBS_SUBDIR[0] = 0x00;
	
		return OtherFile;
		
	}	
}


#ifdef WEB_LOGIN_CHECK
/*******************************************************************
 *	檢查首頁登入密碼正確與否
 *
 *	
 *******************************************************************/
int WebLoginCheck()
{
	if(strstr(skin_file->filename, HTML_Announce))
	{
		if(PSCorrect == Correct)
		{
			UpdateUserRec(request_rec->URLParaType, &curuser, NULL);

#ifdef WEB_EVENT_LOG
			sprintf(log, "LOGIN ID=\"%s\" UA=\"%s\"", curuser.userid, request_rec->user_agent);
			weblog_line(log, server->access_log, request_rec->fromhost, request_rec->atime);
#endif
		}
		else if(strcmp(username, "guest") && (strlen(username)!=0 && PSCorrect != Correct))
		{
			return WEB_INVALID_PASSWORD;
		}
	}
	
	return WEB_OK;
}
#endif


/*******************************************************************
 *	根據 URLParaType 執行 GET 的要求
 *
 *	
 *	return WebRespondType
 *******************************************************************/
int DoGetRequest(REQUEST_REC *rc, BOARDHEADER *board, POST_FILE *pf)
{
	char *p, *boardname;
	int URLParaType = rc->URLParaType;
	char fname[PATHLEN];
	
	boardname = board->filename;

	if(URLParaType == Redirect)
	{
		/* redirect target must seted in ParseURI() */
		return WEB_REDIRECT;
	}
	
	if(PSCorrect != Correct
	&&(URLParaType == MailList
	|| URLParaType == MailRead
	|| URLParaType == SkinModify))
	{
		return WEB_USER_NOT_LOGIN;
	}
	

	if(URLParaType == PostList 
	|| URLParaType == PostRead 
	|| URLParaType == TreaList
	|| URLParaType == TreaRead
	|| URLParaType == SkinModify
	|| URLParaType == Board)
	{
		if(get_board(board, boardname) <= 0 || board->filename[0] == '\0')
			return WEB_BOARD_NOT_FOUND;
		
		if((board->brdtype & BRD_PRIVATE))
		{
#ifdef NSYSUBBS
			/* only SYSOP can access private board */
			if(!HAS_PERM(PERM_SYSOP) || PSCorrect != Correct)	
			{
				return WEB_BOARD_NOT_FOUND;
			}
			else if(strcmp(auth_code, AUTH_CODE))
			{
				return WEB_UNAUTHORIZED;
			}
#else
			return WEB_BOARD_NOT_FOUND;
#endif
		}

		if(board->brdtype & BRD_WEBSKIN)	/* Board has custom html skin */
		{
			char *skin, web_board_dir[PATHLEN];
		
			if(URLParaType == SkinModify)
			{
				if(strlen(pf->POST_NAME) != 0)
				{
					xstrncpy(web_board_dir, pf->POST_NAME, PATHLEN);
					skin = strrchr(web_board_dir, '/') + 1;
					setskinfile(pf->POST_NAME, boardname, skin);
				}
			}
			else if(!strstr(skin_file->filename, HTML_BoardModify))
			{
				/* set specfic skin file to custom file */
				xstrncpy(web_board_dir, skin_file->filename, PATHLEN);
				skin = strrchr(web_board_dir, '/') + 1;
				setskinfile(skin_file->filename, boardname, skin);
			}
		}
		else
		{
			if(strstr(skin_file->filename, HTML_SkinModify))
				return WEB_FILE_NOT_FOUND;
		}
	}

	if(strstr(skin_file->filename, HTML_BoardModify) 
	&&(!HAS_PERM(PERM_SYSOP) || PSCorrect != Correct))
	{
		return WEB_FILE_NOT_FOUND;
	}
	
	switch(URLParaType)
	{
		case TreaRead:
		case PostRead:
			if(GetPostInfo(board, pf) != WEB_OK)
				return WEB_FILE_NOT_FOUND;
			
			break;

		case TreaList:
		case PostList:
			pf->total_rec = get_num_records(pf->POST_NAME, FH_SIZE);
		
			break;
			
		case MailList:
			if(PSCorrect == Correct)
				pf->total_rec = get_num_records(pf->POST_NAME, FH_SIZE);
			else
				pf->total_rec = 0;
		
			break;

		case MailRead:
			if(PSCorrect == Correct)
			{
				int RESULT = GetPostInfo(board, pf);
				
				if(RESULT != WEB_OK)
					return RESULT;
			}
			break;
		
		case UserList:
		case BoardList:
		case TreaBoardList:
		case UserData:
		case SkinModify:
			/* do nothing here.. */
		
			break;
			
		case UserQuery:
			/* put USER_REC in curuser for query */
			if (!get_passwd(&curuser, username))
			{
				bzero(&curuser, sizeof(USEREC));
				return WEB_USER_NOT_FOUND;
			}
			break;
		
		case Board:	/* cuscom webboard */
		case Mail:	/* ?? */
#if 0
			fprintf(fp_out, "DoGetRequest Board,Mail:[%s]", skin_file->filename);
			fflush(fp_out);
#endif
			if(CacheState(skin_file->filename, NULL) <0
			&& !isfile(skin_file->filename))
			{
				return WEB_FILE_NOT_FOUND;
			}
			break;
			
		default:
#if 0
			fprintf(fp_out, "DoGetRequest default:[%s]\r\n", skin_file->filename);
			fflush(fp_out);
#endif
			
			xstrncpy(fname, skin_file->filename, sizeof(fname));
			
			if(isBadURI(fname))
			{
				BBS_SUBDIR[0] = 0x00;
				return WEB_BAD_REQUEST;
			}
			
			sprintf(skin_file->filename, "%s%s", HTML_PATH, fname+1);
#if 0		
			fprintf(fp_out, "skin_file->filename=[%s]\r\n", skin_file->filename);
			fflush(fp_out);
#endif
			if(CacheState(skin_file->filename, NULL) == -1)	/* file not in cache */
			{
				if(isdir(skin_file->filename))
				{
					p = skin_file->filename + strlen(skin_file->filename) -1;
				#if 0
					fprintf(fp_out, "p=[%s]\r\n", p);
					fflush(fp_out);
				#endif
					if(*p == '/')
					{
						strcat(skin_file->filename, DEFAULT_HTML);
					}
					else
					{
						sprintf(skin_file->filename, "%s/", fname);
						return WEB_REDIRECT;
					}
				}
				else
				{
					if((p = strrchr(fname+1, '/')) == NULL)
						p = fname;
				#if 0
					fprintf(fp_out, "p1=[%s]\r\n", p);
					fflush(fp_out);
				#endif
					if(!strcmp(p, "/boards") 
					|| !strcmp(p, "/treasure") 
					|| !strcmp(p, "/mail") 
					|| !strcmp(p, "/users"))
					{
						sprintf(skin_file->filename, "%s/", fname);
						return WEB_REDIRECT;
					}
				}
				
				if(!isfile(skin_file->filename))
				{
					BBS_SUBDIR[0] = 0x00;
					return WEB_FILE_NOT_FOUND;
				}
			}
			
#ifdef WEB_LOGIN_CHECK
			return WebLoginCheck();
#endif

	}
	
	return WEB_OK;
	
}

/*******************************************************************
 *	根據 URLParaType 執行 POST 的要求
 *
 *	return HttpRespondType
 *******************************************************************/
int DoPostRequest(REQUEST_REC *r, BOARDHEADER *board, POST_FILE *pf)
{
	int result, URLParaType;
	int start, end;
	char *form_data, *boardname;
	
	result = WEB_ERROR;
	URLParaType = r->URLParaType;
	boardname = board->filename;
	
	/* Get FORM data */	
	if((form_data = GetFormBody(r->content_length, WEBBBS_ERROR_MESSAGE)) == NULL)
		return WEB_ERROR;
	
#ifdef DEBUG
	weblog_line(form_data, server->debug_log, request_rec->fromhost, request_rec->atime);
#endif
	
	if(PSCorrect == nLogin && URLParaType == PostSend)
	{
		/* PostSend allow username&password in form body without login */
		char pass[PASSLEN*3];
			
		GetPara2(username, "Name", form_data, IDLEN, "");	/* get userdata from form */
		GetPara2(pass, "Password", form_data, PASSLEN*3, "");
		Convert(pass, password);
		
		PSCorrect = CheckUserPassword(username, password);
	}
	
	if(URLParaType == PostSend 
	|| URLParaType == TreaSend
	|| URLParaType == PostEdit
	|| URLParaType == PostForward
	|| URLParaType == TreaForward
	|| URLParaType == PostDelete
	|| URLParaType == SkinModify)
	{
		if (get_board(board, boardname) <= 0 || board->filename[0] == '\0')
			return WEB_BOARD_NOT_FOUND;
	}
	
	if (PSCorrect == Correct 
	|| (PSCorrect == gLogin && (URLParaType == PostSend || URLParaType == TreaSend))
	|| URLParaType == UserNew)
	{
		char path[PATHLEN];
		
		switch(URLParaType)
		{
			case PostSend:
			case TreaSend:
				if((result = PostArticle(form_data, board, pf)))
				{
				#if 1
					if(URLParaType == TreaSend)
					{
						if(strlen(pf->POST_NAME))
							sprintf(skin_file->filename, "/%streasure/%s/%s/$",
								BBS_SUBDIR, boardname, pf->POST_NAME);
						else
							sprintf(skin_file->filename, "/%streasure/%s/$",
								BBS_SUBDIR, boardname);
					}
					else
					{
						sprintf(skin_file->filename, "/%sboards/%s/",
							BBS_SUBDIR, boardname);
					}
				#endif
				
					if(PSCorrect == Correct)
						UpdateUserRec(URLParaType, &curuser, board);
				}
				break;
			
			case MailSend:
				if((result = PostArticle(form_data, board, pf)))
				{
					sprintf(skin_file->filename, "/%smail/",	BBS_SUBDIR);
					UpdateUserRec(URLParaType, &curuser, NULL);
				}
				break;

			case PostEdit:
				if((result = EditArticle(form_data, board, pf)))
				{
					sprintf(skin_file->filename, "/%sboards/%s/%s.html",
						BBS_SUBDIR, boardname, pf->fh.filename);
				}
				break;
			
			case PostForward:
			case TreaForward:
			case MailForward:
				if((result = ForwardArticle(form_data, board, pf)))
				{
					find_list_range(&start, &end, pf->num, DEFAULT_PAGE_SIZE, pf->total_rec);
					setdotfile(path, pf->POST_NAME, NULL);
					sprintf(skin_file->filename, "/%s%s%d-%d",
						BBS_SUBDIR, path, start, end);
				}
				break;
			
			case PostDelete:
			case TreaDelete:
			case MailDelete:
				if((result = DeleteArticle(form_data, board, pf)))
				{
					if(URLParaType == PostDelete)
					{
						find_list_range(&start, &end, pf->num, DEFAULT_PAGE_SIZE, pf->total_rec);
						sprintf(skin_file->filename, "/%sboards/%s/%d-%d",
							BBS_SUBDIR, boardname, start, end);
					}
					else if(URLParaType == TreaDelete)
					{
						setdotfile(path, pf->POST_NAME, NULL);
						sprintf(skin_file->filename, "/%s%s",
							BBS_SUBDIR, path);
					}
					else	/* MailDelete */
					{
						sprintf(skin_file->filename, "/%smail/",	BBS_SUBDIR);
					}
				}
				break;
				
			case UserNew:
				if((result = NewUser(form_data, &curuser)))
					sprintf(skin_file->filename, "%s%s%s", 
						HTML_PATH, BBS_SUBDIR, HTML_UserNewOK);
				break;
			
			case UserData:
				if((result = UpdateUserData(form_data, &curuser)))
					sprintf(skin_file->filename, "/%susers/%s", 
						BBS_SUBDIR, HTML_UserData);
				break;
			
			case UserPlan:
				if((result = UpdateUserPlan(form_data, &curuser)))
					sprintf(skin_file->filename, "/%susers/%s",
						BBS_SUBDIR, HTML_UserPlan);
				break;
			
			case UserSign:
				if((result = UpdateUserSign(form_data, &curuser)))
					sprintf(skin_file->filename, "/%susers/%s", 
						BBS_SUBDIR, HTML_UserSign);
				break;

			case UserFriend:
				if((result = UpdateUserFriend(form_data, &curuser)))
					sprintf(skin_file->filename, "/%susers/%s", 
						BBS_SUBDIR, HTML_UserFriend);
				break;

#ifdef WEB_ADMIN
			case BoardModify:	/* admin function */
				if(!HAS_PERM(PERM_SYSOP)
#ifdef NSYSUBBS
				|| !strstr(request_rec->fromhost, "140.17.12.")
#endif
				)
				{
					sprintf(WEBBBS_ERROR_MESSAGE, 
						"%s 沒有權限修改看板設定", username);
					result = WEB_ERROR;
				}
				else if((result = ModifyBoard(form_data, board)))
					sprintf(skin_file->filename, "/%sboards/%s/%s",
						BBS_SUBDIR, boardname, HTML_BoardModify);
				break;
#endif
				
			case SkinModify:	/* customize board skins */
				if(strcmp(username, board->owner) && !HAS_PERM(PERM_SYSOP))
				{
					sprintf(WEBBBS_ERROR_MESSAGE, 
						"%s 沒有權限修改討論區介面", username);
						result = WEB_ERROR;
				}
				else if(!(board->brdtype & BRD_WEBSKIN))
				{
					sprintf(WEBBBS_ERROR_MESSAGE, 
						"討論區 [%s] 尚未打開自定介面功\能", boardname);
					result = WEB_ERROR;
				}
				else if((result = ModifySkin(form_data, board, pf)))
				{
					sprintf(skin_file->filename, "%s%s%s", 
						HTML_PATH, BBS_SUBDIR, HTML_SkinModifyOK);
				}
				break;

			default:
				return WEB_BAD_REQUEST;
		}
	}
	else
	{
		if(PSCorrect == nLogin)
		{
			if (URLParaType == PostSend)
			    strcpy(WEBBBS_ERROR_MESSAGE, "請輸入帳號及密碼後方能張貼佈告");
			else
				return WEB_USER_NOT_LOGIN;
	    }
    	else if(PSCorrect == gLogin)
			return	WEB_GUEST_NOT_ALLOW;
		else
			return WEB_INVALID_PASSWORD;
	}
	
	free(form_data);
	
#ifdef WEB_EVENT_LOG
	if(result == WEB_OK || result == WEB_OK_REDIRECT)
		weblog_line(log, server->access_log, request_rec->fromhost, request_rec->atime);
#endif

	return result;

}

/*******************************************************************
 *	according to WebRespondType to set error message
 *
 *******************************************************************/
void SetErrorMessage(char *msg, int web_respond, int maxlen)
{
	maxlen -= 32;	/* just preserve space for msg */
	
	switch(web_respond)
	{
		case WEB_USER_NOT_FOUND:
			sprintf(msg, "使用者 [%s] 不存在或名稱錯誤", username);
			break;

		case WEB_USER_NOT_LOGIN:
			sprintf(msg, "%s", MSG_USER_NOT_LOGIN);
			break;
	
		case WEB_USER_NOT_IDENT:
			sprintf(msg, "%s %s", username, MSG_USER_NOT_IDENT);
			break;
	
		case WEB_BOARD_NOT_FOUND:
			sprintf(msg, "討論區  [%s] 不存在或名稱錯誤", cboard->filename);
			break;

		case WEB_BAD_REQUEST:
			sprintf(msg, "Bad Request: %s ", request_rec->request_method);
			strncat(msg, request_rec->URI, maxlen);
			break;
		
		case WEB_UNAUTHORIZED:
			sprintf(msg, "㊣㊣ %s 密碼錯誤 ㊣㊣", username);
			break;
			
		case WEB_GUEST_NOT_ALLOW:
			strcpy(msg, "Guest 無權限執行此功\能");
			break;
			
		case WEB_FORBIDDEN:
			sprintf(msg, "※※ %s 立入禁止 ※※", username);
			break;
			
		case WEB_FILE_NOT_FOUND:
			sprintf(msg, "%s: ", MSG_FILE_NOT_FOUND);
			strncat(msg, request_rec->URI, maxlen);
			break;
		
		case WEB_NOT_IMPLEMENTED:
			sprintf(msg, "Method Not Implemented: %s ", request_rec->request_method);
			strncat(msg, request_rec->URI, maxlen);
			break;
	
		case WEB_INVALID_PASSWORD:
			sprintf(msg, "%s 密碼錯誤<br>請檢查帳號、密碼是否正確填寫", username);
			break;
		
		default:
			sprintf(msg, "Unknow Error type: %d", web_respond);

	}
}

typedef struct
{
	int web_respond;
	int http_respond;
	char *html;
	BOOL set_html;
	BOOL set_error;
	BOOL show_file;
	BOOL log_error;
}CMD;

CMD	cmd[] = 
{
	{WEB_ERROR, OK, HTML_WebbbsError, TRUE, FALSE, TRUE, TRUE},
	{WEB_OK, OK, NULL, FALSE, FALSE, TRUE, FALSE},
	{WEB_OK_REDIRECT, MOVED_PERMANENTLY, NULL, FALSE, FALSE, FALSE, FALSE},
	{WEB_REDIRECT, MOVED_PERMANENTLY, NULL, FALSE, FALSE, FALSE, FALSE},
	{WEB_NOT_MODIFIED, NOT_MODIFIED, NULL, FALSE, FALSE, FALSE, FALSE},
	{WEB_BAD_REQUEST, BAD_REQUEST, HTML_WebbbsError, TRUE, TRUE, TRUE, TRUE},
	{WEB_UNAUTHORIZED, AUTHORIZATION_REQUIRED, HTML_WebbbsError, TRUE, TRUE, TRUE, TRUE},
	{WEB_FORBIDDEN, FORBIDDEN, HTML_WebbbsError, TRUE, TRUE, TRUE, TRUE},
	{WEB_FILE_NOT_FOUND, FILE_NOT_FOUND, HTML_WebbbsError, TRUE, TRUE, TRUE, TRUE},
	{WEB_BOARD_NOT_FOUND, FILE_NOT_FOUND, HTML_BoardNotFound, TRUE, TRUE, TRUE, TRUE},
	{WEB_USER_NOT_FOUND, FILE_NOT_FOUND, HTML_UserNotFound, TRUE, TRUE, TRUE, TRUE},
	{WEB_USER_NOT_LOGIN, OK, HTML_WebbbsError, TRUE, TRUE, TRUE, TRUE},
	{WEB_USER_NOT_IDENT, OK, HTML_WebbbsError, TRUE, TRUE, TRUE, TRUE},
	{WEB_GUEST_NOT_ALLOW, OK, HTML_WebbbsError, TRUE, TRUE, TRUE, TRUE},
	{WEB_NOT_IMPLEMENTED, METHOD_NOT_IMPLEMENTED, HTML_WebbbsError, TRUE, TRUE, TRUE, TRUE},
	{WEB_INVALID_PASSWORD, OK, HTML_WebbbsError, TRUE, TRUE, TRUE, TRUE},
	
};


/*******************************************************************
 *	根據 WEB Borwser 送過來的指令執行相對應的功能, 並作回應
 *
 *	1.=== parse HTTP Request Type
 *	2.=== parse HTTP Header info
 *	3.=== parse URI
 *	4.check password & set 'PSCorrect'
 *	5.do request 
 *	6.print HTTP Respond header
 *	7.print request body (if any)
 *******************************************************************/
int ParseCommand(char *inbuf)
{
	char *p;
#if 0
	char request[32];
#endif
	SKIN_FILE c_skin_file;
	POST_FILE c_post_file;
	BOARDHEADER c_board;
	
	if (*inbuf == '\0' || *inbuf == '\r' || *inbuf == '\n')
		return WEB_ERROR;
#if 1
	*(inbuf+strlen(inbuf)-2) = '\0';
#endif

	/* initial session data here */
	request_rec->URLParaType = OtherFile;
	xstrncpy(request_rec->host, server->host_name, HOSTLEN);
	request_rec->atime = time(0);
#ifdef PRE_FORK
	(server->childs)[my_num].atime = request_rec->atime;
#endif
	request_rec->num_request++;

	/* must reset for each request */
	cboard = &c_board;
	skin_file = &c_skin_file;
	post_file = &c_post_file;
	bzero(cboard, BH_SIZE);
	bzero(skin_file, SF_SIZE);
	bzero(post_file, PF_SIZE);
	username[0] = 0x00;
	password[0] = 0x00;
	
#ifdef DEBUG
#ifdef TORNADO_OPTIMIZE	/* skip debug log */
	if(!isTORNADO)
#endif
	weblog_line(inbuf, server->debug_log, request_rec->fromhost, request_rec->atime);
	fflush(server->debug_log);
#endif
	
	if((p = strtok(inbuf, " \t\n"))==NULL)
		return WEB_ERROR;
#if 0
	xstrncpy(request, p, sizeof(request)-1);
#endif
	xstrncpy(request_rec->request_method, p, PROTO_LEN);
	
	if((p = strtok(NULL, " \t\n")) == NULL)
		return WEB_ERROR;
	xstrncpy(request_rec->URI, p, URI_LEN);
	
	/* 1.=== parse HTTP Request Type */
	request_rec->HttpRequestType = GetHttpRequestType(request_rec->request_method);
	
	/* 2.=== parse HTTP header info */
	if(request_rec->HttpRequestType != CERTILOG)
		if(ParseHttpHeader(request_rec, server) != WEB_OK)
			return WEB_ERROR;

#ifdef PRE_FORK
	(server->childs)[my_num].status = S_BUSY;
#endif
	
/* 
	log after ParseHttpHeader() to get real fromhost if connect from proxy
*/
#ifdef WEB_ACCESS_LOG
#ifdef TORNADO_OPTIMIZE	/* skip access log */
	if(!isTORNADO)
#endif
	{
		sprintf(log, "%s %s", request_rec->request_method, request_rec->URI);
		weblog_line(log, server->access_log, request_rec->fromhost, request_rec->atime);
		fflush(server->access_log);
	}
#endif

	if(request_rec->HttpRequestType == CERTILOG)
	{
		xstrncpy(username, request_rec->URI, IDLEN);
		if((p = strtok(NULL, " \t\n")) == NULL)
			password[0] = 0x00;
		else
			xstrncpy(password, p, PASSLEN);
	}
	else
	{
		request_rec->URLParaType = ParseURI(request_rec->URI, request_rec, cboard, post_file);
	}

	PSCorrect = CheckUserPassword(username, password);

#if 0
	fprintf(fp_out, "username=%s, password=%s\r\n", username, password);
	fflush(fp_out);
#endif

	switch(request_rec->HttpRequestType)
	{
		case GET:
		case HEAD:
			if(request_rec->HttpRequestType == GET)
				server->M_GET++;
			else
				server->M_HEAD++;
			request_rec->WebRespondType = DoGetRequest(request_rec, cboard, post_file);
			break;
		
		case POST:
			server->M_POST++;
			request_rec->WebRespondType = DoPostRequest(request_rec, cboard, post_file);
			break;
	
		case CERTILOG:	/* certification login (csbbs) */
			if(PSCorrect == Correct)
			{
				UpdateUserRec(request_rec->URLParaType, &curuser, NULL);
				fprintf(fp_out, "800  OK!!\r\n");
			}
			else
			{
				server->error++;
				fprintf(fp_out, "724  密碼錯誤\r\n");
#ifdef WEB_ERROR_LOG
				sprintf(log, "ERR=\"%s 724 密碼錯誤\"", username);
				weblog_line(log, server->error_log, request_rec->fromhost, request_rec->atime);
#endif
			}
			return WEB_OK;

		default:
			request_rec->WebRespondType = WEB_NOT_IMPLEMENTED;
	}

#if 0
	fprintf(fp_out, "[WebRespondType=%d, skin_file=%s]<BR>\r\n", 
		request_rec->WebRespondType, skin_file->filename);
	fprintf(fp_out, " myhostip=[%s], myhostname=[%s]\r\n", 
		server->host_ip, server->host_name);
	fflush(fp_out);
#endif

	if(cmd[(request_rec->WebRespondType)-WEB_RESPOND_TYPE_BASE].set_html)
	{
		sprintf(skin_file->filename, "%s%s%s", 
			HTML_PATH, 
			BBS_SUBDIR, 
			cmd[(request_rec->WebRespondType)-WEB_RESPOND_TYPE_BASE].html);
	}
	
	if(cmd[(request_rec->WebRespondType)-WEB_RESPOND_TYPE_BASE].set_error)
	{
		SetErrorMessage(WEBBBS_ERROR_MESSAGE, 
			request_rec->WebRespondType, sizeof(WEBBBS_ERROR_MESSAGE));
	}

	if(cmd[(request_rec->WebRespondType)-WEB_RESPOND_TYPE_BASE].log_error)
	{
		server->error++;
	}
	
#ifdef WEB_ERROR_LOG
#ifdef TORNADO_OPTIMIZE	/* skip error log */
	if(!isTORNADO 
	&& cmd[(request_rec->WebRespondType)-WEB_RESPOND_TYPE_BASE].log_error)
#else
	if(cmd[(request_rec->WebRespondType)-WEB_RESPOND_TYPE_BASE].log_error)
#endif
	{
		sprintf(log, "ERR=\"%s\" REQ=\"%s %s\" UA=\"%s\"", 
			WEBBBS_ERROR_MESSAGE, 
			request_rec->request_method, 
			request_rec->URI, 
			request_rec->user_agent);
		weblog_line(log, server->error_log, request_rec->fromhost, request_rec->atime);
	}
#endif

	if(cmd[(request_rec->WebRespondType)-WEB_RESPOND_TYPE_BASE].show_file)
	{
		if(!GetFileInfo(skin_file))
		{
			request_rec->WebRespondType = WEB_FILE_NOT_FOUND;
			SetErrorMessage(WEBBBS_ERROR_MESSAGE, request_rec->WebRespondType, sizeof(WEBBBS_ERROR_MESSAGE));
			sprintf(skin_file->filename, "%s%s%s", HTML_PATH, BBS_SUBDIR, HTML_WebbbsError);
			
			if(!isfile(skin_file->filename))
				sprintf(skin_file->filename, "%s%s", HTML_PATH, HTML_WebbbsError);
		}
		else
		{
			if(request_rec->if_modified_since 
			&& skin_file->expire == FALSE
			&& !client_reload(request_rec->pragma))
			{
				if(difftime(request_rec->if_modified_since, skin_file->mtime) == 0)
				{
					request_rec->WebRespondType = WEB_NOT_MODIFIED;
#ifdef WEB_304_LOG
					weblog(skin_file->filename, WEB_304_LOG, request_rec->fromhost);
#endif
				}
			}
		}
	}

#if 0
	fprintf(fp_out, "[username=%s, PSC=%d]<br>\r\n", username, PSCorrect);
	fprintf(fp_out, "[URLParaType=%d, WebRespondType=%d, HttpRespondType=%d]<br>\r\n", 
		request_rec->URLParaType, 
		request_rec->WebRespondType, 
		cmd[(request_rec->WebRespondType)-WEB_RESPOND_TYPE_BASE].http_respond);
	fprintf(fp_out, "[BBS_SUBDIR=%s, boardname=%s, skin_file=%s, POST_NAME=%s]<br>\r\n", 
		BBS_SUBDIR, cboard->filename, skin_file->filename, post_file->POST_NAME);
	fflush(fp_out);
#endif

	request_rec->HttpRespondType = cmd[(request_rec->WebRespondType)-WEB_RESPOND_TYPE_BASE].http_respond;
	ShowHttpHeader(request_rec, skin_file, post_file);

	FlushLogFile(server);
	
	if(cmd[(request_rec->WebRespondType)-WEB_RESPOND_TYPE_BASE].show_file 
	&& request_rec->HttpRequestType != HEAD)
	{	
		ShowFile(skin_file);
	}
	
	return WEB_OK;
}



/*******************************************************************
 * Idle Timeout
 *******************************************************************/
void timeout_check(int s)
{
#if defined(WEB_ACCESS_LOG) || defined(WEB_EVENT_LOG) || defined(WEB_ERROR_LOG) || defined(WEB_REFERER_LOG)
	FlushLogFile(server);
#endif
	if(!request_rec->connection)
	{
		server->timeout++;
#ifdef WEB_TIMEOUT_LOG
		sprintf(log, "PID=%d SOCKET=%d", (int)getpid(), mysocket);
		weblog(log, WEB_TIMEOUT_LOG,  request_rec->fromhost);
#endif
	}

#ifdef KEEP_ALIVE
	lingering_close(mysocket);
#else
	shutdown(0, 2);
	close(mysocket);
#endif

#ifdef PRE_FORK
	siglongjmp(env, 1);
#else
	_exit(14);	/* SIGALRM 14 Exit Alarm Clock */
#endif

}

static void shutdown_server(int sig)
{
	RUNNING = 0;
}

static void sig_segv(int sig)
{
	server->error++;
	server->sigsegv++;
	
#ifdef PRE_FORK
	(server->childs)[my_num].status = S_SIGSEGV;
	(server->childs)[my_num].pid = 0x00;
#endif

#ifdef WEB_ERROR_LOG
	sprintf(log, "ERR=\"%s\" REQ=\"%s %s\" UA=\"%s\"", 
		"Caught SIGSEGV", request_rec->request_method, request_rec->URI, request_rec->user_agent);
	weblog(log, WEB_ERROR_LOG, request_rec->fromhost);
#endif

	_exit(11);	/* SIGSEGV 11 Core Segmentation Fault */
}

#if 0
static void sig_pipe(int sig)
{
	server->error++;
	server->sigpipe++;
	
#ifdef PRE_FORK
	(server->childs)[my_num].status = S_SIGPIPE;
#if 0
	(server->childs)[my_num].pid = 0x00;
#endif
	shutdown(0, 2);
#endif
#ifdef WEB_ERROR_LOG
	sprintf(log, "ERR=\"%s\" REQ=\"%s %s\" UA=\"%s\"", 
		"Caught SIGPIPE", request_rec->request_method, request_rec->URI, request_rec->user_agent);
	weblog_line(log, server->error_log, request_rec->fromhost, request_rec->atime);
	fflush(server->error_log);
#endif
#ifdef PRE_FORK
	siglongjmp(env, 1);
#else
	_exit(13);	/* SIGPIPE 13 Exit Broken Pipe */
#endif
}
#endif


#ifdef PRE_FORK
int sem_lock1(int semid, int op)
{
	struct sembuf sops;

	sops.sem_num = 0;
	sops.sem_flg = SEM_UNDO;
	sops.sem_op = op;
	return semop(semid, &sops, 1);
}


/*******************************************************************
 *	Child Main Loop
 *******************************************************************/
void ChildMain(int num, int sock)
{
	struct sockaddr_in from;
	int aha, ns, on;
	char *host;
	fd_set ibits;
#if 0
	struct timeval wait;
#endif

	signal(SIGCHLD, SIG_IGN);
	signal(SIGALRM, timeout_check);
	signal(SIGTERM, shutdown_server);
	signal(SIGSEGV, sig_segv);
#if 0
	signal(SIGPIPE, sig_pipe);
#endif
	aha = sizeof(from);
	my_num = num;		/* num th. child in slot */
	(server->childs)[my_num].pid = getpid();
	(server->childs)[my_num].access = 0;
	(server->childs)[my_num].accept = 0;
	(server->childs)[my_num].status = S_READY;
	(server->childs)[my_num].ctime = time(0);
	(server->childs)[my_num].atime = time(0);
	fp_in = stdin;
	fp_out = stdout;
	
#if 1
	setvbuf(fp_in, NULL, _IOFBF, (size_t) 8192);
	setvbuf(fp_out, NULL, _IOFBF, (size_t) 8192);
#endif

	sigsetjmp(env, 1);
	

	while(RUNNING == 777)
	{
		alarm(0);

		(server->childs)[my_num].status = S_READY;
		if(sem_lock1(sem_id, SEM_ENTR) == -1)	/* mutual exclude lock */
		{
			if(errno != EINTR)
				sleep(1);
			continue;
		}
		
		(server->childs)[my_num].status = S_ACCEPT;
		
		FD_ZERO(&ibits);
		FD_SET(sock, &ibits);
	#if 0
		wait.tv_sec = 3;
		wait.tv_usec = 0;
	#endif
		if ((on = select(sock+1, &ibits, NULL, NULL, NULL)) < 1)
		{
			sem_lock1(sem_id, SEM_EXIT);
			
			if ((on < 0 && errno == EINTR) || on == 0)
				continue;
			else
			{
				sleep(2);
				continue;
			}
		}
		
		if (!FD_ISSET(sock, &ibits))
		{
			sem_lock1(sem_id, SEM_EXIT);
			continue;
		}
		
		ns = accept(sock, (struct sockaddr *) &from, &aha);
		if (ns < 0 && errno == EINTR)
		{
			sem_lock1(sem_id, SEM_EXIT);
			continue;	
		}
		else
		{
			sem_lock1(sem_id, SEM_EXIT);	/* release lock */
			
			(server->childs)[my_num].accept++;
			(server->childs)[my_num].status = S_WAIT;
			(server->childs)[my_num].socket = ns;
			
			host = inet_ntoa(from.sin_addr);
#ifdef ULTRABBS
			if(strcmp(host, TORNADO_HOST_IP)!=0 
			&& strstr(host, "140.117.12.")==NULL
			&& strstr(host, "140.117.99.")==NULL)
			{
				close(ns);
				sem_lock1(sem_id, SEM_EXIT);
				continue;
			}
#endif
			mysocket = ns;
			
			dup2(ns, STDIN_FILENO);
			dup2(ns, STDOUT_FILENO);
			
			bzero(request_rec, sizeof(REQUEST_REC));
			xstrncpy(request_rec->fromhost, host, HOSTLEN);
			Web(num);
			
#ifdef KEEP_ALIVE
			lingering_close(ns);
#else
			shutdown(0, 2);
			close(ns);
#endif
			(server->childs)[my_num].socket = -1;
			mysocket = -1;
		}
	}
	
	(server->childs)[my_num].pid = 0x00;
	(server->childs)[my_num].status = S_SIGTERM;
	close(sock);
	CloseLogFile(server);
	_exit(0);
	
}

int MakeChild(int i, int sock)
{

	int cpid;
	
	if((cpid = fork()) == -1)
	{
		fprintf(stderr, "webbbs: can't fork child...");
		fflush(stderr);
		return -1;
	}
	
	if(!cpid)
	{
		server->fork++;
		ChildMain(i, sock);
	}
	return cpid;
}

#endif	/* ifdef PRE_FORK */

/*******************************************************************
 *	webbbs child Main Function
 *******************************************************************/
void Web(int child_num)
{
	char inbuf[HTTP_REQUEST_LINE_BUF];
	
#ifndef PER_FORK
	/* PRE_FORK set SIGALRM in ChildMain() */
	signal(SIGALRM, timeout_check);
#endif

#ifdef TORNADO_OPTIMIZE
	if(!strcmp(request_rec->fromhost, TORNADO_HOST_IP))
		isTORNADO = TRUE;
	else
		isTORNADO = FALSE;
#endif

#ifdef KEEP_ALIVE

#ifdef TORNADO_OPTIMIZE
			if(isTORNADO)
				alarm(WEB_TIMEOUT*3);	/* increase tornado timeout */
			else
				alarm(WEB_TIMEOUT);
#else
			alarm(WEB_TIMEOUT);
#endif

	request_rec->num_request = 0;
	do
	{
#if 0
		alarm(0);
		alarm(WEB_KEEP_ALIVE_TIMEOUT);
#endif

#ifdef PRE_FORK
		(server->childs)[child_num].status = S_WAIT;
#endif
		if(fgets(inbuf, sizeof(inbuf), fp_in) != NULL)
		{
			if (*inbuf == '\r' || *inbuf == '\n')
			{
				request_rec->connection = TRUE;
				continue;
			}
			
			server->access++;
#ifdef PRE_FORK
			(server->childs)[child_num].access++;
#endif

			if(ParseCommand(inbuf) == WEB_ERROR)
				break;
			fflush(fp_out);
			if(request_rec->connection)
			{
				alarm(WEB_KEEP_ALIVE_TIMEOUT);
			}
		}
		else
		{
			break;
		}
		
	} while(request_rec->connection);
	
#else	/* NOT KEEP_ALIVE */

#ifdef PRE_FORK
	(server->childs)[child_num].status = S_WAIT;
#endif

	alarm(0);
	alarm(WEB_KEEP_ALIVE_TIMEOUT);

	if (fgets(inbuf, sizeof(inbuf), fp_in))
	{
		server->access++;
#ifdef PRE_FORK
		(server->childs)[child_num].access++;
#endif
		if (*inbuf == '\r' || *inbuf == '\n')
			return;

		alarm(0);

#ifdef TORNADO_OPTIMIZE
		if(isTORNADO)
			alarm(WEB_TIMEOUT*3);
		else
			alarm(WEB_TIMEOUT);
#else
		alarm(WEB_TIMEOUT);
#endif
		ParseCommand(inbuf);
		fflush(fp_out);
	}
#endif

}

void usage(char *prog)
{
	fprintf(stderr, "== Formosa WEB-BBS Server %s ==\n\
		Usage: %s [-b ip] [-p port] [-d] [-c] [-h]\n\
		-b Specify server ip for binding\n\
		-p Specify server port for binding\n\
		-h This help message\n\
		-c Enable allow/deny mode\n", 
			WEB_SERVER_VERSION, prog);
	fflush(stderr);
}

void init_signals(void)
{

	signal(SIGHUP, SIG_IGN);		/* caught SIGHUT then ignore it */
	signal(SIGCHLD, reaper);		/* caught SIGCHLD then execute reaper() */
	signal(SIGTERM, shutdown_server);
	signal(SIGSEGV, sig_segv);
#if 0
	signal(SIGPIPE, sig_pipe);
#endif
	signal(SIGPIPE, SIG_IGN);

#ifdef SIGTTOU
	signal(SIGTTOU, SIG_IGN);
#endif
#ifdef SIGTTIN
	signal(SIGTTIN, SIG_IGN);
#endif
#ifdef SIGTSTP
	signal(SIGTSTP, SIG_IGN);
#endif
#ifdef SIGCONT
	signal(SIGCONT, SIG_IGN);
#endif


}


void write_pidfile(pid_t pid, int port)
{
	FILE *fp;
	char pidfile[PATHLEN];
	
	sprintf(pidfile, "%s.%d", PID_FILE, port);
	
	if ((fp = fopen(pidfile, "w")) != NULL)
	{
		fprintf(fp, "%-d", (int)pid);
		fclose(fp);
		chmod(pidfile, 0644);
	}
}

int unlink_pidfile(int port)
{
	char pidfile[PATHLEN];
	
	sprintf(pidfile, "%s.%d", PID_FILE, port);
	return unlink(pidfile);
}

/*******************************************************************
 * Main
 *******************************************************************/
int
main(int argc, char *argv[])
{
	int aha, on , s;
	struct sockaddr_in from, sin;
	char check = 0;
	int port = DEFAULT_SERVER_PORT;
	pid_t pid;
	time_t now;
	struct hostent *hbuf;				/* lthuang */
	struct in_addr in;
	REQUEST_REC c_request_rec;			/* client request record */
	char myhostname[STRLEN], myhostip[HOSTLEN];
	BOOL spec_bind = FALSE;
#ifdef PRE_FORK
	int max_child = MAX_NUM_CHILD;
#else
	int ns;
	fd_set ibits;
	struct timeval wait;
#endif

	request_rec = &c_request_rec;
	bzero(request_rec, sizeof(REQUEST_REC));
	
#ifdef PRE_FORK	
	while ((s = getopt(argc, argv, "f:p:b:ch")) != -1)
#else
	while ((s = getopt(argc, argv, "p:b:ch")) != -1)
#endif
	{
		switch (s)
		{
			case 'b':	/* assign bind ip */
				strncpy(myhostip, optarg, HOSTLEN);
				spec_bind = TRUE;
				break;
			case 'p':	/* assign bind port */
				port = atoi(optarg);
				break;
#ifdef PRE_FORK	
			case 'f':	/* # of child to fork */
				max_child = atoi(optarg);
				break;
#endif
			case 'c':
				check++;
				break;

			default:
				usage(argv[0]);
				return 0;
		}
	}
	
	if(spec_bind)
	{
		printf("bind ip = %s\n", myhostip);
	}
	
	if (fork() != 0)	/* 複製出一隻一樣的 父程式 */
		exit(0);

	
	for (aha = sysconf(_SC_OPEN_MAX); aha >= 0; aha--)
		close(aha);

	setsid();

#if 0
	if ((aha = open(PATH_DEVNULL, O_RDONLY)) < 0)
	{
		printf("Open %s fail\r\n", PATH_DEVNULL);
		exit(1);
	}
		
	if (aha)
	{
		dup2(aha, 0);
		close(aha);
	}
	dup2(0, 1);
#endif

	
#if 1
    /* close out the standard file descriptors */
    if (freopen(PATH_DEVNULL, "r", stdin) == NULL) {
		fprintf(stderr, "httpd: unable to replace stdin with /dev/null: %s\n",
			strerror(errno));
	/* continue anyhow -- note we can't close out descriptor 0 because we
	 * have nothing to replace it with, and if we didn't have a descriptor
	 * 0 the next file would be created with that value ... leading to
	 * havoc.
	 */
    }
    if (freopen(PATH_DEVNULL, "w", stdout) == NULL) {
		fprintf(stderr, "httpd: unable to replace stdout with /dev/null: %s\n",
			strerror(errno));
    }
    /* stderr is a tricky one, we really want it to be the error_log,
     * but we haven't opened that yet.  So leave it alone for now and it'll
     * be reopened moments later.
     */
#endif
	
	init_signals();

	umask(0);

	if(spec_bind)
	{
		unsigned long int addr;
	
		addr = inet_addr(myhostip);
		if (!(hbuf = gethostbyaddr((char *)&addr, sizeof(addr), AF_INET)))
		{
			perror("gethostbyaddr");
			exit(-1);
		}
	}
	else
	{
		gethostname(myhostname, sizeof(myhostname));
		if (!(hbuf = gethostbyname(myhostname)))
		{
			perror("gethostbyname");
			exit(-1);
		}
	}
	
	xstrncpy(myhostname, hbuf->h_name, STRLEN);
	memcpy(&in.s_addr, *(hbuf->h_addr_list), sizeof(in.s_addr));
	xstrncpy(myhostip, inet_ntoa(in), HOSTLEN);
	if ((s = socket(AF_INET, SOCK_STREAM, 0)) < 0)
	{
		perror("socket");
		exit(1);
	}
	
	on = 1;
	setsockopt(s, SOL_SOCKET, SO_REUSEADDR, (char *) &on, sizeof(on));
#if 1
	on = 1;
	setsockopt(s, SOL_SOCKET, SO_KEEPALIVE,	(char *) &on, sizeof(on));
#endif
#if 1
	on = 8192;
	setsockopt(s, SOL_SOCKET, SO_SNDBUF, (int *) &on, sizeof(on));
	setsockopt(s, SOL_SOCKET, SO_RCVBUF, (int *) &on, sizeof(on));
#endif
#if defined(IP_OPTIONS) && defined(IPPROTO_IP)
	setsockopt(s, IPPROTO_IP, IP_OPTIONS, (char *) NULL, 0);
#endif

	sin.sin_family = AF_INET;
	sin.sin_addr.s_addr = INADDR_ANY;

	/* only consider about myhostip, for running with normal http server */
	if(spec_bind)
		sin.sin_addr.s_addr = inet_addr(myhostip);
	
	sin.sin_port = htons((u_short) port);

	if (bind(s, (struct sockaddr *) &sin, sizeof sin) < 0)
	{
		perror("bind");
		exit(1);
	}

#if 0
#if	defined(SOLARIS) || defined(AIX)
	if (listen(s, 128) < 0)
#elif defined(LINUX)
	if (listen(s, 64) < 0)
#else
	if (listen(s, 5) < 0)
#endif
#endif
	if (listen(s, max_child*3) < 0)
	{
		perror("listen");
		exit(1);
	}
	

	/* ========== init. data here to gain performance ========== */
	pid = getpid();
	init_bbsenv();
	server = attach_shm((SERVER_SHM_KEY+port), SR_SIZE);
	server->access = 0;
	server->error = 0;
	server->fork = 0;
	server->child = 0;
	server->timeout = 0;
	server->sigsegv = 0;
	server->sigpipe = 0;
	server->M_GET = 0;
	server->M_HEAD = 0;
	server->M_POST = 0;
	server->port = port;
	server->pid = pid;
	xstrncpy(server->host_name, myhostname, STRLEN);
	xstrncpy(server->host_ip, myhostip, HOSTLEN);
#ifdef PRE_FORK
	server->max_child = max_child > MAX_NUM_CHILD ? MAX_NUM_CHILD : max_child;
	bzero(server->childs, MAX_NUM_CHILD*sizeof(CHILD_REC));
	sem_id = sem_init(SERVER_SEM_KEY+port);
#endif

	if (check)
		host_deny((char *) NULL);
	
	tzset();
	gmtime(&now);
	localtime(&now);
	time(&now);
	
	sysconf(_SC_PAGESIZE);
	server->start_time = now;
	
	init_cache();
	init_boards();
	init_users();
	
	write_pidfile(pid, port);
	OpenLogFile(server);
	
#ifdef WEB_EVENT_LOG
	sprintf(log, "START %s/%s PID=\"%d\" PORT=\"%d\"", WEB_SERVER_NAME, WEB_SERVER_VERSION, (int)server->pid, server->port);
	weblog_line(log, server->access_log, "127.0.0.1", server->start_time);
	FlushLogFile(server);
#endif
	/* ================================================================== */

	
#ifdef PRE_FORK
	{
		int i;
		
		for(i=0; i<server->max_child; i++)
		{
			MakeChild(i, s);
			
		}
	}

	alarm(0);
	signal(SIGALRM, SIG_IGN);
	sleep(2);	/* wait for child to initial */
	
#endif

	aha = sizeof(from);
	fp_in = stdin;
	fp_out = stdout;
	
	while (RUNNING == 777)
	{
#ifdef PRE_FORK
		int i, ready=0;
		
		for(i=0; i<server->max_child; i++)
		{
			if(server->childs[i].pid == 0)
				MakeChild(i, s);
			else if(server->childs[i].status == S_READY)
				ready++;
		}
		
		/* 
			if not enough ready child for task,
			tell waiting child to abort persistent connection
			to become ready 
		*/
		if(ready <= 2)
		{
			for(i=0; i<server->max_child; i++)
			{
				if((server->childs)[i].pid >0
				&& (server->childs)[i].status == S_WAIT)
					kill((server->childs)[i].pid, SIGALRM);
			}
		}
		
		sleep(5);

#else	/* non PRE_FORK loop */

		FD_ZERO(&ibits);
		FD_SET(s, &ibits);
		
		wait.tv_sec = 5;
		wait.tv_usec = 0;
		
		if ((on = select(s+1, &ibits, 0, 0, &wait)) < 1)
		{
			if ((on < 0 && errno == EINTR) || on == 0)
				continue;
			else
			{
				sleep(5);
				continue;
			}
		}
		
		if (!FD_ISSET(s, &ibits))
			continue;

		if ((ns = accept(s, (struct sockaddr *) &from, &aha)) < 0)
			continue;	/* 沒建立連結，繼續等待 while(1) */
		else
		{
#ifdef ULTRABBS
			char *hs;
			hs = inet_ntoa(from.sin_addr);

			if(strcmp(hs, TORNADO_HOST_IP)!=0 
			&& strstr(hs, "140.117.12.")==NULL
			&& strstr(hs, "140.117.99.")==NULL)
			{
				close(ns);
				continue;
			}
#endif
			switch (fork())
			{
				case -1:		/* error */
					close(ns);
					break;
				case 0:			/* child */
					{
						char *host;

						server->fork++;
						signal(SIGCHLD, SIG_IGN);
						close(s);
                        
						dup2(ns, STDIN_FILENO);
						dup2(ns, STDOUT_FILENO);
					#if 0
						dup2(ns, STDERR_FILENO);
						close(ns);
					#endif
						
						mysocket = ns;
						
						host = inet_ntoa(from.sin_addr);

						if (check && host_deny(host))
						{
							shutdown(0, 2);
							exit(0);
						}

						xstrncpy(request_rec->fromhost, host, HOSTLEN);
						Web(0);
						
#ifdef KEEP_ALIVE
						lingering_close(ns);
#else
						shutdown(0, 2);
						close(ns);
#endif

						_exit(0);	/* child exited normally */
						
					}
				default:		/* parent */
					close(ns);
			}
		}
#endif
	}
	
/*
	now server terminate....
*/
	
#ifdef PRE_FORK
/*
	send SIGTERM to child process 
*/
	{
		int i;
		
		for(i=0; i<server->max_child; i++)
		{
			if((server->childs)[i].pid >0)
				kill((server->childs)[i].pid, SIGTERM);
		}
	}
	while (wait3(&aha, WNOHANG, (struct rusage *) 0) > 0);

	sleep(2);
	sem_cleanup(sem_id);
#endif
	
	close(s);
	unlink_pidfile(server->port);
	
#ifdef WEB_EVENT_LOG
	sprintf(log, "SHUTDOWN %s/%s PID=\"%d\" PORT=\"%d\" ACCESS=\"%d, %d, %d\" ERROR=\"%d\" TIMEOUT=\"%d\" SIGSEGV=\"%d\"", 
		WEB_SERVER_NAME, 
		WEB_SERVER_VERSION, 
		(int)server->pid, 
		server->port,
		server->M_GET,
		server->M_HEAD,
		server->M_POST,
		server->error,
		server->timeout,
		server->sigsegv
	);
	
	weblog_line(log, server->access_log, "127.0.0.1", time(0));
#endif
	CloseLogFile(server);
	
	return 0;
	
}
